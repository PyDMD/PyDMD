

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydmd.havok &mdash; PyDMD 2025.4.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />

  
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b5451040"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            PyDMD
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../code.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">How to contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_of_conduct.html">PyDMD Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LICENSE.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyDMD</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pydmd.havok</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pydmd.havok</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for the Hankel alternative view of Koopman (HAVOK) analysis.</span>

<span class="sd">References:</span>
<span class="sd">- S. L. Brunton, B. W. Brunton, J. L. Proctor, E. Kaiser, and J. N. Kutz,</span>
<span class="sd">Chaos as an intermittently forced linear system, Nature Communications, 8</span>
<span class="sd">(2017), pp. 1-9.</span>
<span class="sd">- S. M. Hirsh, S. M. Ichinaga, S. L. Brunton, J. N. Kutz, and B. W. Brunton,</span>
<span class="sd">Structured time-delay models for dynamical systems with connections to</span>
<span class="sd">frenet-serret frame, Proceedings of the Royal Society A, 477</span>
<span class="sd">(2021). art. 20210097.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.gridspec</span><span class="w"> </span><span class="kn">import</span> <span class="n">GridSpec</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">lsim</span><span class="p">,</span> <span class="n">StateSpace</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.bopdmd</span><span class="w"> </span><span class="kn">import</span> <span class="n">BOPDMD</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_svd</span><span class="p">,</span> <span class="n">differentiate</span>


<div class="viewcode-block" id="HAVOK"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">HAVOK</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hankel alternative view of Koopman (HAVOK) analysis.</span>

<span class="sd">    :param svd_rank: the rank for the truncation; if 0, the method computes the</span>
<span class="sd">        optimal rank and uses it for the truncation; if positive integer, the</span>
<span class="sd">        method uses the argument for the truncation; if float between 0 and 1,</span>
<span class="sd">        the rank is the number of the biggest singular values that are needed</span>
<span class="sd">        to reach the &#39;energy&#39; specified by `svd_rank`; if -1, the method does</span>
<span class="sd">        not compute a truncation.</span>
<span class="sd">    :type svd_rank: int or float</span>
<span class="sd">    :param delays: the number of consecutive time-shifted copies of the</span>
<span class="sd">        data to use when building Hankel matrices. Note that if examining an</span>
<span class="sd">        n-dimensional data set, this means that the resulting Hankel matrix</span>
<span class="sd">        will contain n * `delays` rows.</span>
<span class="sd">    :type delays: int</span>
<span class="sd">    :param lag: the number of time steps between each time-shifted copy of</span>
<span class="sd">        data in the Hankel matrix. This means that each row of the Hankel</span>
<span class="sd">        matrix will be separated by a time-step of dt * `lag`.</span>
<span class="sd">    :type lag: int</span>
<span class="sd">    :param num_chaos: the number of forcing terms to use in the HAVOK model.</span>
<span class="sd">    :type num_chaos: int</span>
<span class="sd">    :param structured: whether to perform standard HAVOK or structured HAVOK</span>
<span class="sd">        (sHAVOK). If `True`, sHAVOK is performed, otherwise HAVOK is performed.</span>
<span class="sd">        Note that sHAVOK cannot be performed with a `BOPDMD` model.</span>
<span class="sd">    :type structured: bool</span>
<span class="sd">    :param lstsq: method used for computing the HAVOK operator if a DMD method</span>
<span class="sd">        is not provided. If True, least-squares is used, otherwise the pseudo-</span>
<span class="sd">        inverse is used. This parameter is ignored if `dmd` is provided.</span>
<span class="sd">    :type lstsq: bool</span>
<span class="sd">    :param dmd: DMD instance used to compute the HAVOK operator. If `None`,</span>
<span class="sd">        least-squares or the pseudo-inverse is used depending on `lstsq`.</span>
<span class="sd">    :type dmd: DMDBase</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">svd_rank</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">delays</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">num_chaos</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">structured</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lstsq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">dmd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_svd_rank</span> <span class="o">=</span> <span class="n">svd_rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delays</span> <span class="o">=</span> <span class="n">delays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span> <span class="o">=</span> <span class="n">lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span> <span class="o">=</span> <span class="n">num_chaos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structured</span> <span class="o">=</span> <span class="n">structured</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lstsq</span> <span class="o">=</span> <span class="n">lstsq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span> <span class="o">=</span> <span class="n">dmd</span>

        <span class="c1"># Keep track of the original data and Hankel matrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshots</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ho_snapshots</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Keep track of SVD information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vecs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Keep track of the full HAVOK operator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_r</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">delays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of delays used when building Hankel matrices.</span>

<span class="sd">        :return: the number of Hankel matrix delays.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delays</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the lag used when building Hankel matrices.</span>

<span class="sd">        :return: the number of time-steps used for Hankel matrix lag.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">snapshots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the input data (time-series or space-flattened).</span>

<span class="sd">        :return: the matrix that contains the original input data.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_snapshots</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ho_snapshots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the time-delay data matrix (i.e. the Hankel matrix).</span>

<span class="sd">        :return: the matrix that contains the time-delayed data.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ho_snapshots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ho_snapshots</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the times of the input data.</span>

<span class="sd">        :return: the vector that contains the times of the input data.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">modes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the U matrix from the SVD of the Hankel matrix. Note that the</span>
<span class="sd">        columns of this matrix are referred to as the eigen-time-delay modes.</span>

<span class="sd">        :return: matrix containing the eigen-time-delay modes.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vecs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vecs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">singular_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the singular value spectrum of the Hankel matrix.</span>

<span class="sd">        :return: the singular values of the Hankel matrix.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vals</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">delay_embeddings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all of the HAVOK embeddings (linear dynamics and forcing).</span>
<span class="sd">        Coordinates are stored as columns of the returned matrix.</span>
<span class="sd">        Note that this is the V matrix from the SVD of the Hankel matrix.</span>

<span class="sd">        :return: matrix containing all of the HAVOK embeddings.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">linear_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the HAVOK embeddings that are governed by linear dynamics.</span>
<span class="sd">        Coordinates are stored as columns of the returned matrix.</span>

<span class="sd">        :return: matrix containing the linear HAVOK embeddings.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span><span class="p">[:,</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forcing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the HAVOK embeddings that force the linear dynamics.</span>
<span class="sd">        Coordinates are stored as columns of the returned matrix.</span>

<span class="sd">        :return: matrix containing the chaotic forcing terms.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span><span class="p">[:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the full HAVOK regression model,</span>
<span class="sd">        which contains A, B, and the bad fit.</span>

<span class="sd">        :return: the full HAVOK regression model.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">A</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the matrix A in the HAVOK relationship dv/dt = Av + Bu, where v</span>
<span class="sd">        denotes the linear HAVOK embeddings and u denotes the forcing terms.</span>

<span class="sd">        :return: linear dynamics matrix A.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span><span class="p">[:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span><span class="p">,</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">B</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the matrix B in the HAVOK relationship dv/dt = Av + Bu, where v</span>
<span class="sd">        denotes the linear HAVOK embeddings and u denotes the forcing terms.</span>

<span class="sd">        :return: forcing dynamics matrix B.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span><span class="p">[:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span> <span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">eigs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the eigenvalues of the linear HAVOK operator A.</span>

<span class="sd">        :return: the eigenvalues of the operator A.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of HAVOK embeddings utilized by the HAVOK model.</span>
<span class="sd">        Note that this is essentially the integer rank truncation used.</span>

<span class="sd">        :return: rank of the HAVOK model.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span>

<div class="viewcode-block" id="HAVOK.hankel"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK.hankel">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">hankel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a data matrix X as a 1-D or 2-D numpy.ndarray, uses the `delays`</span>
<span class="sd">        and `lag` attributes to return the data as a 2-D Hankel matrix.</span>

<span class="sd">        :param X: (m,) or (n, m) array of data.</span>
<span class="sd">        :type X: numpy.ndarray</span>
<span class="sd">        :return: Hankel matrix of data.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be a 1-D or 2-D numpy array.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Check that the input data contains enough observations.</span>
        <span class="n">m_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_delays</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">m_min</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Not enough snapshots provided for &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_delays</span><span class="si">}</span><span class="s2"> delays and lag </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lag</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Please provide at least </span><span class="si">{</span><span class="n">m_min</span><span class="si">}</span><span class="s2"> snapshots.&quot;</span>
            <span class="p">)</span>

        <span class="n">Hm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_delays</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delays</span><span class="p">,</span> <span class="n">Hm</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_delays</span><span class="p">):</span>
            <span class="n">H</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span> <span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span> <span class="o">+</span> <span class="n">Hm</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="HAVOK.dehankel"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK.dehankel">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">dehankel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Hankel matrix H as a 2-D numpy.ndarray, uses the `delays`</span>
<span class="sd">        and `lag` attributes to unravel the data in the Hankel matrix.</span>

<span class="sd">        :param H: 2-D Hankel matrix of data.</span>
<span class="sd">        :type H: numpy.ndarray</span>
<span class="sd">        :return: de-Hankeled (m,) or (n, m) array of data.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">H</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be a 2-D numpy array.&quot;</span><span class="p">)</span>

        <span class="n">Hn</span><span class="p">,</span> <span class="n">Hm</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Hn</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delays</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Hm</span> <span class="o">+</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_delays</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span><span class="p">))</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_delays</span><span class="p">):</span>
            <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span> <span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span> <span class="o">+</span> <span class="n">Hm</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">n</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="HAVOK.fit"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK.fit">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the HAVOK analysis.</span>

<span class="sd">        :param X: the input snapshots.</span>
<span class="sd">        :type X: numpy.ndarray or iterable</span>
<span class="sd">        :param t: the input time vector or uniform time-step between snapshots.</span>
<span class="sd">        :type t: {numpy.ndarray, iterable} or {int, float}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Confirm that delays, lag, and num_chaos are positive integers.</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_delays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;delays, lag, and num_chaos must be positive integers.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Confirm that the input data is 1-D or 2-D.</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input data must be a 1-D or 2-D array.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Compute the Hankel matrix.</span>
        <span class="n">hankel_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hankel</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Check the input time information and set the time vector.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

            <span class="c1"># Throw error if the time vector is not 1-D or the correct length.</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_samples</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Please provide a 1-D array of </span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s2"> time values.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Generate warning if the times are not uniformly-spaced.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Input snapshots are unevenly-spaced in time. &quot;</span>
                    <span class="s2">&quot;Unexpected results may occur because of this.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Set the time step - this is ignored if using BOP-DMD.</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Perform structured HAVOK (sHAVOK).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structured</span><span class="p">:</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">compute_svd</span><span class="p">(</span><span class="n">hankel_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_svd_rank</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">V2</span> <span class="o">=</span> <span class="n">compute_svd</span><span class="p">(</span><span class="n">hankel_matrix</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">V_dot</span> <span class="o">=</span> <span class="p">(</span><span class="n">V2</span> <span class="o">-</span> <span class="n">V</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>

        <span class="c1"># Perform standard HAVOK.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">compute_svd</span><span class="p">(</span><span class="n">hankel_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_svd_rank</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">V_dot</span> <span class="o">=</span> <span class="n">differentiate</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Generate an error if too few HAVOK embeddings are being used.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;HAVOK is attempting to use r = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_r</span><span class="si">}</span><span class="s2"> embeddings &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;when r should be at least </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Try increasing the number of delays or providing &quot;</span>
                <span class="s2">&quot;a positive integer argument for svd_rank.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Use lstsq or pinv to compute the HAVOK operator.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lstsq</span><span class="p">:</span>
                <span class="n">havok_operator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">V_dot</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">havok_operator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V_dot</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Use the provided DMDBase object to compute the operator.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">,</span> <span class="n">BOPDMD</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">time</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structured</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Structured HAVOK cannot be performed with BOP-DMD. &quot;</span>
                        <span class="s2">&quot;Performing normal HAVOK instead...&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">V_dot</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c1"># Compute the full system matrix.</span>
            <span class="n">havok_operator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">multi_dot</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">modes</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">eigs</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">modes</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># Set the input data information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshots</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ho_snapshots</span> <span class="o">=</span> <span class="n">hankel_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span>

        <span class="c1"># Set the SVD information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vecs</span> <span class="o">=</span> <span class="n">U</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vals</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span> <span class="o">=</span> <span class="n">V</span>

        <span class="c1"># Save the full HAVOK operator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span> <span class="o">=</span> <span class="n">havok_operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span>
            <span class="n">havok_operator</span><span class="p">[:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span><span class="p">,</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span><span class="p">]</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="HAVOK.predict"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK.predict">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forcing</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">V0</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use a custom forcing input to make system predictions.</span>

<span class="sd">        :param forcing: (m, `num_chaos`) array of forcing inputs.</span>
<span class="sd">        :type forcing: numpy.ndarray</span>
<span class="sd">        :param time: (m,) array that contains the times that correspond with</span>
<span class="sd">            the provided forcing inputs. These will also be the times at which</span>
<span class="sd">            system predictions are computed.</span>
<span class="sd">        :type time: numpy.ndarray</span>
<span class="sd">        :param V0: (`r` - `num_chaos`,) array that contains the initial</span>
<span class="sd">            condition of the linear dynamics. This array should contain the</span>
<span class="sd">            linear dynamics evaluated at the first time in the `time` array.</span>
<span class="sd">            If not provided, this initial condition is assumed to be the</span>
<span class="sd">            initial condition stored in this `HAVOK` model instance. If `V0`</span>
<span class="sd">            is an int, `V0` is assumed to be the index of the stored linear</span>
<span class="sd">            dynamics to use as an initial condition.</span>
<span class="sd">        :type V0: {numpy.ndarray, iterable} or int</span>
<span class="sd">        :return: system predictions evaluated at the times in `time`.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V0</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">V0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_dynamics</span><span class="p">[</span><span class="n">V0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">V0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_embeddings_to_original</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_embeddings</span><span class="p">(</span><span class="n">forcing</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">V0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstructed_embeddings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the reconstructed time-delay embeddings.</span>

<span class="sd">        :return: the matrix that contains the reconstructed embeddings.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_embeddings</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">)],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear_dynamics</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstructed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the reconstructed data.</span>

<span class="sd">        :return: the matrix that contains the reconstructed snapshots.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_embeddings_to_original</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_embeddings</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HAVOK.compute_threshold"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK.compute_threshold">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">compute_threshold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">forcing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the distribution of forcing terms to determine a threshold at which</span>
<span class="sd">        the absolute value of the forcing is large enough to be considered</span>
<span class="sd">        &quot;active&quot;. This method uses a histogram of the forcing signal values</span>
<span class="sd">        and a forcing event probability in order to estimate this threshold.</span>

<span class="sd">        :param forcing: (m,) array of forcing inputs to be thresholded.</span>
<span class="sd">            Alternatively, users may provide an integer, which will be used to</span>
<span class="sd">            index the stored forcing terms. By default, the first forcing term</span>
<span class="sd">            stored will be used.</span>
<span class="sd">        :type forcing: {numpy.ndarray, iterable} or int</span>
<span class="sd">        :param p: desired approximate probability that a forcing event occurs.</span>
<span class="sd">            Note that `p` must be a float between 0.0 and 1.0, and that smaller</span>
<span class="sd">            values of `p` will result in larger threshold values. If `p` is an</span>
<span class="sd">            integer instead, `p` will be used to index candidate thresholds</span>
<span class="sd">            that are located at the intersection of the forcing term histogram</span>
<span class="sd">            and a fitted Gaussian distribution.</span>
<span class="sd">        :type p: int or float</span>
<span class="sd">        :param bins: `bins` input to the `numpy.histogram` function.</span>
<span class="sd">        :type bins: int or sequence of scalars or str</span>
<span class="sd">        :param plot: whether or not to plot the computed histogram of forcing</span>
<span class="sd">            values and the computed threshold. A Gaussian distribution fitted</span>
<span class="sd">            to the computed histogram is also plotted if `plot=True`.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :param plot_kwargs: optional dictionary of plot parameters. Currently,</span>
<span class="sd">            one may set the figure size, the y-axis limits, and whether or not</span>
<span class="sd">            to use a semilogy scale.</span>
<span class="sd">        :type plot_kwargs: dict</span>
<span class="sd">        :return: active threshold for the absolute value of the forcing terms.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">forcing</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">forcing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[:,</span> <span class="n">forcing</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">forcing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">forcing</span><span class="p">)</span>

        <span class="c1"># Compute histogram of the forcing values.</span>
        <span class="n">hy</span><span class="p">,</span> <span class="n">hx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">forcing</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">hx</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">hx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">hx</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># get bin centers</span>
        <span class="n">hy</span> <span class="o">/=</span> <span class="n">hy</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Fit a Gaussian to the forcing values.</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">forcing</span><span class="p">)</span>
        <span class="n">gauss</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">hx</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>
        <span class="n">gauss</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gauss</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># Use Gaussian intersection.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">gauss</span> <span class="o">-</span> <span class="n">hy</span>
            <span class="n">sgn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">ind_signchange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sgn</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">sgn</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">thres_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hx</span><span class="p">[</span><span class="n">ind_signchange</span><span class="p">])</span>
            <span class="n">thres_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hx</span><span class="p">[</span><span class="n">ind_signchange</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">threshold_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">thres_1</span> <span class="o">+</span> <span class="n">thres_2</span><span class="p">))</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold_candidates</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use probability p of switching.</span>
            <span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">hx</span><span class="p">[</span><span class="n">ind1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">hx</span><span class="p">[</span><span class="n">ind2</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="c1"># Set the plotting parameters first.</span>
            <span class="k">if</span> <span class="n">plot_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plot_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s2">&quot;figsize&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
                <span class="n">plot_kwargs</span><span class="p">[</span><span class="s2">&quot;figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;semilogy&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
                <span class="n">plot_kwargs</span><span class="p">[</span><span class="s2">&quot;semilogy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Plot the histogram, fitted Gaussian, and the threshold.</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">plot_kwargs</span><span class="p">[</span><span class="s2">&quot;figsize&quot;</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">hx</span><span class="p">,</span> <span class="n">hy</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Forcing&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">hx</span><span class="p">,</span> <span class="n">gauss</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Gaussian&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Threshold&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=-</span><span class="n">threshold</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;$v_r$&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;$p$&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">plot_kwargs</span><span class="p">[</span><span class="s2">&quot;semilogy&quot;</span><span class="p">]:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">()</span>
            <span class="k">if</span> <span class="s2">&quot;ylim&quot;</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">plot_kwargs</span><span class="p">[</span><span class="s2">&quot;ylim&quot;</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">threshold</span></div>

<div class="viewcode-block" id="HAVOK.plot_summary"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK.plot_summary">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot_summary</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index_linear</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="n">index_forcing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">forcing_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_jump_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">true_switch_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a 5-element summarizing plot that contains the following:</span>
<span class="sd">        - the time-series used to apply HAVOK</span>
<span class="sd">        - the full linear operator, which contains A, B, and the bad fit</span>
<span class="sd">        - the first linear embedding term and the first forcing term</span>
<span class="sd">        - the HAVOK embeddings, along with active forcing times</span>
<span class="sd">        - the HAVOK reconstruction of the embeddings.</span>

<span class="sd">        :param num_plot: The number of time points to plot across all subplots.</span>
<span class="sd">            By default, all available data points are plotted.</span>
<span class="sd">        :type num_plot: int</span>
<span class="sd">        :param index_linear: Tuple of indices of the linear embeddings to be</span>
<span class="sd">            plotted. May contain either 2 or 3 valid indices. The final two</span>
<span class="sd">            subplots will be plotted in 2-D or 3-D depending on the number of</span>
<span class="sd">            indices provided.</span>
<span class="sd">        :type index_linear: iterable</span>
<span class="sd">        :param index_forcing: Index of the forcing term to be plotted. Note</span>
<span class="sd">            that this index refers to indices of the forcing term itself rather</span>
<span class="sd">            than the full matrix of time-delay embeddings. Hence if 0, the</span>
<span class="sd">            first forcing term will be plotted, and so on.</span>
<span class="sd">        :type index_forcing: int</span>
<span class="sd">        :param forcing_threshold: Threshold value at which the absolute value</span>
<span class="sd">            of the forcing signal is considered large enough to be &quot;active&quot;.</span>
<span class="sd">        :type forcing_threshold: float</span>
<span class="sd">        :param min_jump_dist: The minimum number of indices used to separate</span>
<span class="sd">            distinct forcing events. Decreasing this parameter will lead to</span>
<span class="sd">            many short forcing events, while increasing this parameter will</span>
<span class="sd">            lead to fewer longer forcing events.</span>
<span class="sd">        :type min_jump_dist: int</span>
<span class="sd">        :param true_switch_indices: Optional vector that contains the indices</span>
<span class="sd">            at which true chaotic bursting occurs. If provided, true bursting</span>
<span class="sd">            times are plotted on top of the forcing term.</span>
<span class="sd">        :type true_switch_indices: numpy.ndarray or iterable</span>
<span class="sd">        :param figsize: Tuple in inches defining the figure size.</span>
<span class="sd">        :type figsize: tuple(int, int)</span>
<span class="sd">        :param dpi: Figure resolution.</span>
<span class="sd">        :type dpi: int</span>
<span class="sd">        :param filename: If specified, the plot is saved at `filename`.</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to call fit().&quot;</span><span class="p">)</span>

        <span class="c1"># Plot as many time points as possible.</span>
        <span class="k">if</span> <span class="n">num_plot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_plot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_delay_embeddings</span><span class="p">)</span>

        <span class="c1"># Compute a threshold based on the distribution of all forcing terms.</span>
        <span class="k">if</span> <span class="n">forcing_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">forcing_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_threshold</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[:,</span> <span class="n">index_forcing</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># Use the time step to estimate a reasonable jump.</span>
        <span class="k">if</span> <span class="n">min_jump_dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_jump_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Get index slices at which the forcing is considered active.</span>
        <span class="n">forcing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[:</span><span class="n">num_plot</span><span class="p">,</span> <span class="n">index_forcing</span><span class="p">]</span>
        <span class="n">active_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_plot</span><span class="p">)[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">forcing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">forcing_threshold</span>
        <span class="p">]</span>
        <span class="n">active_slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_slices</span><span class="p">(</span><span class="n">active_indices</span><span class="p">,</span> <span class="n">min_jump_dist</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figure</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">ax4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_linear</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
            <span class="n">ax6</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">ax6</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">])</span>

        <span class="c1"># (1) plot the time-series data (first coordinate).</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Time series&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[:</span><span class="n">num_plot</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshots</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">num_plot</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>

        <span class="c1"># (2) plot the HAVOK operator.</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Regression model&quot;</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span><span class="o">.</span><span class="n">real</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
                <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                <span class="n">vmin</span><span class="o">=-</span><span class="n">vmax</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;PuOr&quot;</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">fraction</span><span class="o">=</span><span class="mf">0.046</span><span class="p">,</span>
            <span class="n">pad</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_havok_operator</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_chaos</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="c1"># (3) plot the linear HAVOK embeddings (first coordinate).</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Linear dynamics&quot;</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[:</span><span class="n">num_plot</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear_dynamics</span><span class="p">[:</span><span class="n">num_plot</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:blue&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="c1"># (4) plot the HAVOK forcing term with activation times.</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Forcing&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[:</span><span class="n">num_plot</span><span class="p">],</span> <span class="n">forcing</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">active_slices</span><span class="p">:</span>
            <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="n">ind1</span><span class="p">:</span><span class="n">ind2</span><span class="p">],</span> <span class="n">forcing</span><span class="p">[</span><span class="n">ind1</span><span class="p">:</span><span class="n">ind2</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">true_switch_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Remove indices that fall outside of the plotting range.</span>
            <span class="n">outside_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">true_switch_indices</span> <span class="o">&gt;=</span> <span class="n">num_plot</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outside_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">true_switch_indices</span> <span class="o">=</span> <span class="n">true_switch_indices</span><span class="p">[:</span> <span class="n">outside_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[:</span><span class="n">num_plot</span><span class="p">][</span><span class="n">true_switch_indices</span><span class="p">],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">true_switch_indices</span><span class="p">)),</span>
                <span class="s2">&quot;*&quot;</span><span class="p">,</span>
                <span class="n">mec</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
                <span class="n">mfc</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
                <span class="n">ms</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># (5) plot the embedded attractor with activation.</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Embedded attractor&quot;</span><span class="p">)</span>
        <span class="n">linear_dynamics</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear_dynamics</span><span class="p">[:</span><span class="n">num_plot</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_linear</span>
        <span class="p">]</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">linear_dynamics</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">active_slices</span><span class="p">:</span>
            <span class="n">active_dynamics</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">linear_dynamics</span><span class="p">[</span><span class="n">ind1</span><span class="p">:</span><span class="n">ind2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_linear</span>
            <span class="p">]</span>
            <span class="n">ax5</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">active_dynamics</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">ax5</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>

        <span class="c1"># (6) plot the reconstructed attractor.</span>
        <span class="n">ax6</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Reconstructed attractor&quot;</span><span class="p">)</span>
        <span class="n">reconstruction</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reconstructed_embeddings</span><span class="p">[:</span><span class="n">num_plot</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_linear</span>
        <span class="p">]</span>
        <span class="n">ax6</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">reconstruction</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:blue&quot;</span><span class="p">)</span>
        <span class="n">ax6</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># Save plot if filename is provided.</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="HAVOK._compute_embeddings"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK._compute_embeddings">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_embeddings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forcing</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">V0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that uses the fitted HAVOK model to reconstruct the</span>
<span class="sd">        time-delay embeddings for a generic forcing term, set of times, and</span>
<span class="sd">        initial condition for the time-delay embeddings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build a system with the following form:</span>
        <span class="c1">#   dx/dt = Ax + Bu</span>
        <span class="c1">#   y = Cx + Du</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">))</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>
        <span class="n">havok_system</span> <span class="o">=</span> <span class="n">StateSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>

        <span class="c1"># Reconstruct the linear dynamics using the HAVOK system.</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="n">lsim</span><span class="p">(</span>
            <span class="n">havok_system</span><span class="p">,</span>
            <span class="n">U</span><span class="o">=</span><span class="n">forcing</span><span class="p">,</span>
            <span class="n">T</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">X0</span><span class="o">=</span><span class="n">V0</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">embeddings</span></div>

<div class="viewcode-block" id="HAVOK._embeddings_to_original"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK._embeddings_to_original">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_embeddings_to_original</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that uses SVD and Hankel parameter information stored</span>
<span class="sd">        in the HAVOK model to convert data in time-delay embedding space back</span>
<span class="sd">        to the space of the original input data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vecs</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singular_vals</span><span class="p">[:</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">multi_dot</span><span class="p">([</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dehankel</span><span class="p">(</span><span class="n">H</span><span class="p">)</span></div>

<div class="viewcode-block" id="HAVOK._get_index_slices"><a class="viewcode-back" href="../../havok.html#pydmd.havok.HAVOK._get_index_slices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_index_slices</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">min_jump_dist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that, given an array x of indices at which to plot,</span>
<span class="sd">        computes and returns the beginning and ending index for each</span>
<span class="sd">        consecutive set of indices.</span>

<span class="sd">        :Example:</span>
<span class="sd">            &gt;&gt;&gt; a = np.array([2, 3, 4, 5, 10, 11, 12, 25, 26, 28])</span>
<span class="sd">            &gt;&gt;&gt; _get_index_slices(a, min_jump_dist=2)</span>
<span class="sd">            [(2, 5), (10, 12), (25, 28)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the locations within x where a significant jump occurs.</span>
        <span class="n">jumps</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">min_jump_dist</span>
        <span class="n">jump_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">jumps</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">jump_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">jumps</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">index_slices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">jump_starts</span><span class="p">,</span> <span class="n">jump_ends</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">index_slices</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2025, PyDMD Contributors.
      <span class="lastupdated">Last updated on Apr 01, 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>