

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydmd.paramdmd &mdash; PyDMD 2025.2.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />

  
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=4acbabd7"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            PyDMD
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../code.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">How to contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_of_conduct.html">PyDMD Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LICENSE.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyDMD</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pydmd.paramdmd</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pydmd.paramdmd</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for the parametric Dynamic Mode Decomposition.</span>

<span class="sd">References:</span>
<span class="sd">- A Dynamic Mode Decomposition Extension for the Forecasting of Parametric </span>
<span class="sd">Dynamical Systems, F. Andreuzzi, N. Demo, G. Rozza, 2023, SIAM Journal on </span>
<span class="sd">Applied Dynamical Systems</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>


<span class="c1"># roll by one position the shape of X. if X.shape == (a,b,c), the returned</span>
<span class="c1"># NumPy array&#39;s shape is (b,c,a)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">back_roll_shape</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Roll by one position the shape of `X`. if `X.shape == (a,b,c)`, the returned</span>
<span class="sd">    NumPy array&#39;s shape is `(b,c,a)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">roll_shape</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Roll by one position the shape of `X`. if `X.shape == (a,b,c)`, the returned</span>
<span class="sd">    NumPy array&#39;s shape is `(c,a,b)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<div class="viewcode-block" id="ParametricDMD"><a class="viewcode-back" href="../../paramdmd.html#pydmd.paramdmd.ParametricDMD">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">ParametricDMD</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of the parametric Dynamic Mode Decomposition proposed in</span>
<span class="sd">    arXiv:2110.09155v1. Both the *monolithic* and *partitioned* methods are</span>
<span class="sd">    available, see the documentation of the parameter `dmd` for more details.</span>

<span class="sd">    :param dmd: Instance(s) of :class:`dmdbase.DMDBase`, used by the</span>
<span class="sd">        paramtric DMD for the prediction of future spatial modal coefficients.</span>
<span class="sd">        If `dmd` is a `list` the *partitioned* approach is selected, in this</span>
<span class="sd">        case the number of parameters in the training set should be equal to</span>
<span class="sd">        the number of DMD instances provided. If `dmd` is not a list, we employ</span>
<span class="sd">        the monolithic approach.</span>
<span class="sd">    :type dmd: DMDBase or list</span>
<span class="sd">    :param spatial_pod: Instance of an object usable for the generation of a</span>
<span class="sd">        ROM of the dataset (see for instance the class</span>
<span class="sd">        `POD &lt;https://mathlab.github.io/EZyRB/pod.html&gt;`_ from the Python</span>
<span class="sd">        library `EZyRB &lt;https://github.com/mathLab/EZyRB&gt;`_).</span>
<span class="sd">    :param approximation: An interpolator following the standard</span>
<span class="sd">        learning-prediction pattern (`fit()` -&gt; `predict()`). For some</span>
<span class="sd">        convenient wrappers see those implemented in</span>
<span class="sd">        `EZyRB &lt;https://github.com/mathLab/EZyRB&gt;`_).</span>
<span class="sd">    :param bool light: Whether this instance should be light or not. A light</span>
<span class="sd">        instance uses less memory since it caches a smaller number of resources.</span>
<span class="sd">        Setting `light=True` might invalidate several properties (see also</span>
<span class="sd">        :meth:`training_modal_coefficients`).</span>
<span class="sd">    :param dmd_fit_args: Positional arguments to be passed to the `fit` method</span>
<span class="sd">        of the given DMD instance.</span>
<span class="sd">    :param dmd_fit_kwargs: Keyword arguments to be passed to the `fit` method</span>
<span class="sd">        of the given DMD instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dmd</span><span class="p">,</span>
        <span class="n">spatial_pod</span><span class="p">,</span>
        <span class="n">approximation</span><span class="p">,</span>
        <span class="n">light</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dmd_fit_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dmd_fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span> <span class="o">=</span> <span class="n">dmd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spatial_pod</span> <span class="o">=</span> <span class="n">spatial_pod</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_approximation</span> <span class="o">=</span> <span class="n">approximation</span>

        <span class="k">if</span> <span class="n">dmd_fit_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dmd_fit_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dmd_fit_args</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected list, tuple or None for dmd_fit_args&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dmd_fit_args</span> <span class="o">=</span> <span class="n">dmd_fit_args</span>
        <span class="k">if</span> <span class="n">dmd_fit_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dmd_fit_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dmd_fit_kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected dict or None for dmd_fit_kwargs&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dmd_fit_kwargs</span> <span class="o">=</span> <span class="n">dmd_fit_kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_training_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_instants</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_space_dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_light</span> <span class="o">=</span> <span class="n">light</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_training_modal_coefficients</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_partitioned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return `True` if this instance is partitioned, `False` if it is</span>
<span class="sd">        monolithic.</span>

<span class="sd">        :type: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reference_dmd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An object used as a reference for several properties like</span>
<span class="sd">        :func:`dmd_time` and :func:`dmd_timesteps`. If this instance is</span>
<span class="sd">        monolithic the returned value is `self._dmd`, otherwise it is the first</span>
<span class="sd">        item of the list `self._dmd`.</span>

<span class="sd">        :return: The object used as a reference.</span>
<span class="sd">        :rtype: pydmd.DMDBase</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dmd_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The time dictionary used by the reference DMD instance (see also</span>
<span class="sd">        :func:`_reference_dmd`). Note that when you set this attribute the</span>
<span class="sd">        value is set only for the reference DMD (see :func:`_reference_dmd`),</span>
<span class="sd">        however when :func:`_predict_modal_coefficients` is called the values</span>
<span class="sd">        of all DMDs become consistent.</span>

<span class="sd">        :getter: Return the time dictionary used by the reference DMD instance.</span>
<span class="sd">        :setter: Set the given time dictionary in the field `dmd_time` for all</span>
<span class="sd">            DMD instances.</span>
<span class="sd">        :type: pydmd.dmdbase.DMDTimeDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">dmd_time</span>

    <span class="nd">@dmd_time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dmd_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">dmd_time</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dmd_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The timesteps in the output of this instance, which coincides with the</span>
<span class="sd">        timesteps in the output of the reference of this instance (see</span>
<span class="sd">        :func:`_reference_dmd`).</span>

<span class="sd">        :return: The timesteps in the output of this instance.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">dmd_timesteps</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">original_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The original time dictionary used by this instance, which coincides</span>
<span class="sd">        with the original dictionary used by the reference of this instance</span>
<span class="sd">        (see :func:`_reference_dmd`).</span>

<span class="sd">        :return: The original time dictionary used by this instance.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">original_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">original_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The original timesteps in the input fed to this instance, which</span>
<span class="sd">        coincides with the original timesteps in the input fed to the reference</span>
<span class="sd">        of this instance (see :func:`_reference_dmd`).</span>

<span class="sd">        :return: The original timesteps in the input fed to this instance.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">original_timesteps</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">training_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The original parameters passed when `self.fit` was called, represented</span>
<span class="sd">        as a 2D array (the index of the parameter vary along the first</span>
<span class="sd">        dimension).</span>

<span class="sd">        :type: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training_parameters</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_training_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of `self._original_parameters`, while checking that the</span>
<span class="sd">        value provided is a 2D array.</span>

<span class="sd">        :param numpy.ndarray: A 2D array which contains the original</span>
<span class="sd">            parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameters must be stored in 2D arrays.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_training_parameters</span> <span class="o">=</span> <span class="n">params</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The new parameters to be used in `reconstructed_data`, represented</span>
<span class="sd">        as a 2D array (the index of the parameter vary along the first</span>
<span class="sd">        dimension). For, instance, the following feeds a set of four 3D</span>
<span class="sd">        parameters to `ParametricDMD`:</span>

<span class="sd">            &gt;&gt;&gt; from pydmd import ParametricDMD</span>
<span class="sd">            &gt;&gt;&gt; pdmd = ParametricDMD(...)</span>
<span class="sd">            &gt;&gt;&gt; pdmd.fit(...)</span>
<span class="sd">            &gt;&gt;&gt; p0 = [0.1, 0.2, 0.1]</span>
<span class="sd">            &gt;&gt;&gt; p1 = [0.1, 0.2, 0.3],</span>
<span class="sd">            &gt;&gt;&gt; p2 = [0.2, 0.2, 0.2],</span>
<span class="sd">            &gt;&gt;&gt; p3 = [0.1, 0.2, 0.2]</span>
<span class="sd">            &gt;&gt;&gt; pdmd.parameters = np.array([p0,p1,p2,p3])</span>

<span class="sd">        Therefore, when we collect the results from `reconstructed_data`:</span>

<span class="sd">            &gt;&gt;&gt; result = pdmd.reconstructed_data</span>
<span class="sd">            &gt;&gt;&gt; # reconstruction corresponding to p0</span>
<span class="sd">            &gt;&gt;&gt; rec_p0 = result[0]</span>
<span class="sd">            &gt;&gt;&gt; # reconstruction corresponding to p1</span>
<span class="sd">            &gt;&gt;&gt; rec_p1 = result[1]</span>
<span class="sd">            &gt;&gt;&gt; ...</span>

<span class="sd">        :getter: Return the current parameters.</span>
<span class="sd">        :setter: Change the current parameters.</span>
<span class="sd">        :type: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_parameters&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameters must be stored in 2D arrays.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_arrange_parametric_snapshots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arrange the given parametric snapshots (see :func:`fit` for an overview</span>
<span class="sd">        of the shape of `X`) into a 2D matrix such that the shape is distributed</span>
<span class="sd">        as follows:</span>

<span class="sd">        - 0: Space;</span>
<span class="sd">        - 1: Time/Parameter.</span>

<span class="sd">        Time varies faster than the parameter along the columns of the matrix.</span>

<span class="sd">        An overview of the shape of the resulting matrix:</span>

<span class="sd">         .. math::</span>

<span class="sd">            M = \\begin{bmatrix}</span>
<span class="sd">                    x_1(t_1,\\mu_1) &amp; \dots &amp; x_1(t_n,\\mu_1) &amp; x_1(t_1,\\mu_1)</span>
<span class="sd">                        &amp; \dots &amp; x_1(t_{n-1},\\mu_k) &amp; x_1(t_n,\\mu_k)\\\\</span>
<span class="sd">                    \\vdots &amp; \\dots &amp; \\vdots &amp; \\vdots &amp; \\dots &amp; \\vdots</span>
<span class="sd">                        &amp; \\dots\\\\</span>
<span class="sd">                    x_m(t_1,\\mu_1) &amp; \dots &amp; x_m(t_n,\\mu_1) &amp; x_m(t_1,\\mu_1)</span>
<span class="sd">                        &amp; \dots &amp; x_m(t_{n-1},\\mu_k) &amp; x_m(t_n,\\mu_k)</span>
<span class="sd">                \\end{bmatrix}</span>

<span class="sd">        :math:`x(t, \mu) \in \mathbb{R}^m` is the functon which represents the</span>
<span class="sd">        parametric system at time :math:`t` with the parameter :math:`\\mu`.</span>

<span class="sd">        :param X: Parametric snapshots (distribition of axes like in</span>
<span class="sd">            :func:`fit`).</span>
<span class="sd">        :type X: numpy.ndarray</span>
<span class="sd">        :return: Parametric snapshots arranged in a 2D matrix like explained</span>
<span class="sd">            above.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># swap parameters dimension and space dimension</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_training_modal_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space_timemu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the POD modal coefficient from the given matrix, and put</span>
<span class="sd">        the resulting coefficients (along with their time evolution in matrix</span>
<span class="sd">        form) into a list.</span>

<span class="sd">        In symbols, from the given matrix :math:`X^x_{t,\mu} \in</span>
<span class="sd">        \mathbb{R}^{m \\times nk}` we compute the modal</span>
<span class="sd">        coefficients corresponding to its columns. At this point we have</span>
<span class="sd">        something like this:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\widetilde{X}^s_{t,\mu} = \\begin{bmatrix}</span>
<span class="sd">                    \\widetilde{x}_1(t_1,\\mu_1), &amp; \dots &amp;</span>
<span class="sd">                        \\widetilde{x}_1(t_n,\\mu_1), &amp;</span>
<span class="sd">                        \\widetilde{x}_1(t_1,\\mu_1), &amp; \dots &amp;</span>
<span class="sd">                        \\widetilde{x}_1(t_{n-1},\\mu_k), &amp;</span>
<span class="sd">                        \\widetilde{x}_1(t_n,\\mu_k)\\\\</span>
<span class="sd">                    \\vdots &amp; \\dots &amp; \\vdots &amp; \\vdots &amp; \\dots &amp; \\vdots &amp;</span>
<span class="sd">                        \\dots\\\\</span>
<span class="sd">                    \\widetilde{x}_p(t_1,\\mu_1), &amp; \dots &amp; x_p(t_n,\\mu_1) &amp;</span>
<span class="sd">                        \\widetilde{x}_p(t_1,\\mu_1), &amp; \dots &amp;</span>
<span class="sd">                        \\widetilde{x}_p(t_{n-1},\\mu_k), &amp;</span>
<span class="sd">                        \\widetilde{x}_p(t_n,\\mu_k)</span>
<span class="sd">                \\end{bmatrix} \in \mathbb{R}^{p \\times nk}</span>

<span class="sd">        Detecting the sub-matrices corresponding to the time evolution of the</span>
<span class="sd">        POD modal coefficients corresponding to a particular realization of the</span>
<span class="sd">        system for some parameter :math:`\\mu_i`, we may rewrite this matrix as</span>
<span class="sd">        follows:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\widetilde{X}^s_{t,\mu} = \\begin{bmatrix}</span>
<span class="sd">                    \\widetilde{X}_{\\mu_1}, &amp; \dots &amp; \\widetilde{X}_{\\mu_1}</span>
<span class="sd">            \\end{bmatrix}</span>

<span class="sd">        The returned list contains the matrices</span>
<span class="sd">        :math:`\\widetilde{X}_{\\mu_i} \in \\mathbb{p \\times n}`.</span>

<span class="sd">        :param space_timemu: A matrix containing parametric/time snapshots like</span>
<span class="sd">            the matrix returned by :func:`_arrange_parametric_snapshots`. The</span>
<span class="sd">            input size should be `p x nk` where `p` is the dimensionality of</span>
<span class="sd">            the full-dimensional space, `k` is the number of training parameters</span>
<span class="sd">            and `n` is the number of time instants used for the training.</span>
<span class="sd">        :type space_timemu: numpy.ndarray</span>
<span class="sd">        :return: A list of `k` matrices. Each matrix has shape `r x n` where `r`</span>
<span class="sd">            is the dimensionality of the reduced POD space, and `n`, `k` are the</span>
<span class="sd">            same of the parameter `space_timemu`.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">spatial_modal_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spatial_pod</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">space_timemu</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="n">space_timemu</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">spatial_modal_coefficients</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="ParametricDMD.fit"><a class="viewcode-back" href="../../paramdmd.html#pydmd.paramdmd.ParametricDMD.fit">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">training_parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the parametric Dynamic Modes Decomposition from the input data</span>
<span class="sd">        stored in the array `X`. The shape of the parameter `X` must be</span>
<span class="sd">        used as follows:</span>

<span class="sd">        - 0: Training parameters;</span>
<span class="sd">        - 1: Space;</span>
<span class="sd">        - 2: Training time instants.</span>

<span class="sd">        The parameter `training_parameters` contains the list of training</span>
<span class="sd">        parameters corresponding to the training datasets in `X`. For instance,</span>
<span class="sd">        `training_parameters[0]` is the parameter which generated the dataset</span>
<span class="sd">        in `X[0]`. For this reason `len(training_parameters)` should be equal</span>
<span class="sd">        to `X.shape[0]`.</span>

<span class="sd">        :param numpy.ndarray X: Training snapshots of the parametric system,</span>
<span class="sd">            observed for two or more parameters and in multiple time instants.</span>
<span class="sd">        :param numpy.ndarray training_parameters: Training parameters</span>
<span class="sd">            corresponding to the snapshots in `X`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_parameters</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected number of snapshots for the given&quot;</span>
                <span class="s2">&quot;parameters. Received </span><span class="si">{}</span><span class="s2"> parameters, and </span><span class="si">{}</span><span class="s2"> snapshots&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">training_parameters</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># we store these values for faster access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_instants</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid number of DMD instances provided: &quot;</span>
                <span class="s2">&quot;expected n_train=</span><span class="si">{}</span><span class="s2">, got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># store the training parameters: they will be used in</span>
        <span class="c1"># `reconstructed_data`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_training_parameters</span><span class="p">(</span><span class="n">training_parameters</span><span class="p">)</span>

        <span class="c1"># arrange the parametric snapshots in a convenient way to perform POD</span>
        <span class="n">space_timemu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrange_parametric_snapshots</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># obtain POD modal coefficients from the training set</span>
        <span class="n">training_modal_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_training_modal_coefficients</span><span class="p">(</span>
            <span class="n">space_timemu</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_light</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_training_modal_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">training_modal_coefficients</span>
            <span class="p">)</span>

        <span class="c1"># fit DMD(s) with POD modal coefficients</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span><span class="p">:</span>
            <span class="c1"># partitioned parametric DMD</span>
            <span class="k">for</span> <span class="n">dmd</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">,</span> <span class="n">training_modal_coefficients</span><span class="p">):</span>
                <span class="n">dmd</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd_fit_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd_fit_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spacemu_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">training_modal_coefficients</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="n">spacemu_time</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd_fit_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_dmd_fit_kwargs</span>
            <span class="p">)</span></div>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># getter properties for intermediate values of the computation</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">training_modal_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modal coefficients of the input dataset. Since this is cached after</span>
<span class="sd">        calls to :func:`fit` this property needs to be called after :func:`fit`,</span>
<span class="sd">        and `light` should be set to `False` in the constructor of the class.</span>

<span class="sd">        The tensor returned has the following shape:</span>

<span class="sd">        - 0: Training parameters;</span>
<span class="sd">        - 1: Dimensionality of the POD sub-space;</span>
<span class="sd">        - 2: Time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_light</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Light instances do not cache the property</span>
<span class="sd">`training_modal_coefficients`.&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training_modal_coefficients</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Property not available now, did you call `fit()`?&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training_modal_coefficients</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forecasted_modal_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modal coefficients forecasted for the input parameters.</span>

<span class="sd">        The tensor returned has the following shape:</span>

<span class="sd">        - 0: Training parameters;</span>
<span class="sd">        - 1: Dimensionality of the POD sub-space;</span>
<span class="sd">        - 2: Time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">forecasted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_modal_coefficients</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">forecasted</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">forecasted</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpolated_modal_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modal coefficients forecasted and then interpolated for the untested</span>
<span class="sd">        parameters.</span>

<span class="sd">        The tensor returned has the following shape:</span>

<span class="sd">        - 0: Parameters;</span>
<span class="sd">        - 1: Dimensionality of the POD sub-space;</span>
<span class="sd">        - 2: Time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">forecasted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_modal_coefficients</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_missing_modal_coefficients</span><span class="p">(</span><span class="n">forecasted</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_predict_modal_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict future spatial modal coefficients in the time instants in</span>
<span class="sd">        `dmd_time`.</span>

<span class="sd">        :return: Predicted spatial modal coefficients. Shape: `rk x n` (`r`:</span>
<span class="sd">            dimensionality of POD subspace, `k`: number of training parameters,</span>
<span class="sd">            `n`: number of snapshots).</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_partitioned</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dmd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">:</span>
                <span class="c1"># we want to &quot;bound&quot; this DMD objects&#39; dmd_time</span>
                <span class="n">dmd</span><span class="o">.</span><span class="n">dmd_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_dmd</span><span class="o">.</span><span class="n">dmd_time</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">dmd</span><span class="p">:</span> <span class="n">dmd</span><span class="o">.</span><span class="n">reconstructed_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dmd</span><span class="o">.</span><span class="n">reconstructed_data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_interpolate_missing_modal_coefficients</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">forecasted_modal_coefficients</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate spatial modal coefficients for the (untested) parameters</span>
<span class="sd">        stored in `parameters`. The interpolation uses the interpolator</span>
<span class="sd">        provided in the constructor of this instance.</span>

<span class="sd">        The returned value is a 3D tensor, its shape is used as follows:</span>

<span class="sd">        - 0: Parameters;</span>
<span class="sd">        - 1: Reduced POD space;</span>
<span class="sd">        - 2: Time.</span>

<span class="sd">        :param numpy.ndarray forecasted_modal_coefficients: An array of spatial</span>
<span class="sd">            modal coefficients for tested parameters. The shape is used like in</span>
<span class="sd">            the matrix returned by :func:`_predict_modal_coefficients`.</span>
<span class="sd">        :return: An array of (interpolated) spatial modal coefficients for</span>
<span class="sd">            untested parameters.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Unknown parameters not found. Did you set `ParametricDMD.parameters`?&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="n">approx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approximation</span>
        <span class="n">forecasted_modal_coefficients</span> <span class="o">=</span> <span class="n">forecasted_modal_coefficients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ntrain</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">forecasted_modal_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">interpolate_future_pod_coefficients</span><span class="p">(</span><span class="n">time_slice</span><span class="p">):</span>
            <span class="n">approx</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_parameters</span><span class="p">,</span> <span class="n">time_slice</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">approx</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">interpolate_future_pod_coefficients</span><span class="p">(</span><span class="n">time_slice</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">time_slice</span> <span class="ow">in</span> <span class="n">roll_shape</span><span class="p">(</span><span class="n">forecasted_modal_coefficients</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstructed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the reconstructed data, for the time instants specified in</span>
<span class="sd">        `dmd_time`, and the parameters stored in `parameters`.</span>

<span class="sd">        The shape of the returned data is distributed as follows:</span>

<span class="sd">        - 0: Parameters;</span>
<span class="sd">        - 1: Space;</span>
<span class="sd">        - 2: Time.</span>

<span class="sd">        :return: Snapshots predicted/interpolated using parametric DMD and the</span>
<span class="sd">            given method for ROM.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">forecasted_modal_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_modal_coefficients</span><span class="p">()</span>
        <span class="n">interpolated_modal_coefficients</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_missing_modal_coefficients</span><span class="p">(</span>
                <span class="n">forecasted_modal_coefficients</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spatial_pod</span><span class="o">.</span><span class="n">expand</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">interpolated_modal_coefficients</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ParametricDMD.save"><a class="viewcode-back" href="../../paramdmd.html#pydmd.paramdmd.ParametricDMD.save">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the object to `fname` using the pickle module.</span>

<span class="sd">        :param str fname: the name of file where the reduced order model will</span>
<span class="sd">            be saved.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from pydmd import ParametricDMD</span>
<span class="sd">        &gt;&gt;&gt; pdmd = ParametricDMD(...) #  Construct here the rom</span>
<span class="sd">        &gt;&gt;&gt; pdmd.fit(...)</span>
<span class="sd">        &gt;&gt;&gt; pdmd.save(&#39;pydmd.pdmd&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParametricDMD.load"><a class="viewcode-back" href="../../paramdmd.html#pydmd.paramdmd.ParametricDMD.load">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the object from `fname` using the pickle module.</span>

<span class="sd">        :return: The `ReducedOrderModel` loaded</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from pydmd import ParametricDMD</span>
<span class="sd">        &gt;&gt;&gt; pdmd = ParametricDMD.load(&#39;pydmd.pdmd&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(pdmd.reconstructed_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2025, PyDMD Contributors.
      <span class="lastupdated">Last updated on Feb 01, 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>